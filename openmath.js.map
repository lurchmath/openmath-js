{"version":3,"sources":["openmath.litcoffee"],"names":["OM","OMNode","bind","fn","me","apply","arguments","tree1","this","tree","Object","defineProperty","get","p","t","v","n","cd","uri","s","b","child","j","len","ref","ref1","results1","c","length","variable","tokenTypes","checkJSON","object","checkKeys","identRE","key","l","len1","len2","m","reason","ref2","ref3","symbol","value","hasOwnProperty","a","JSON","parse","error","list","slice","call","keys","indexOf","test","isNaN","isFinite","Uint8Array","Array","decode","json","setParents","message","node","k","ref4","ref5","encode","stringify","equals","other","attributes","recur","element","index","sameObjectAs","copy","result","integer","float","string","bytearray","name","application","arg","args","push","attribution","attrs","shift","binding","body","head","vars","others","pattern","simpleDecode","input","children","expr","halves","int","match","next","o","originally","stack","state","tokenType","tokens","type","exec","text","split","unshift","parseInt","parseFloat","replace","RegExp","simpleEncode","variables","join","findInParent","parent","findChild","indexInParent","getAttribute","address","inThis","concat","remove","splice","replaceWith","original","keySymbol","cdRE","nameRE","removeAttribute","setAttribute","newValue","base1","freeVariables","boundByThis","free","varname","isFree","boundHere","walk","occursFree","findThis","isFreeToReplace","subtreeToReplace","context","saved","replaceFree","replacement","save","childrenSatisfying","filter","descendantsSatisfying","results","hasDescendantSatisfying","flo","str","byt","sym","app","att","bin","err","simple","encodeAsIdentifier","charTo4Digits","i","charCodeAt","toString","decodeIdentifier","ident","String","fromCharCode","prototype","toXML","indent","evaluate","tmp","_this","e","func","indices","Number","Math","PI","exp","pow","abs","sin","cos","tan","asin","acos","atan","log","base","exports"],"mappings":"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","file":"openmath.js","sourcesContent":["\n# OpenMath module\n\nThis module implements an encoding of OpenMath objects as JSON.  It is *not*\nan official encoding endorsed by the OpenMath Society.  It is merely my own\nchoice of how to do the encoding, in the absence of an official standard\n(that I could find).\n\nObjects are encoded as follows.  (If these phrases are unfamiliar to you,\nsee [the OpenMath Standard,\nv2.0](http://www.openmath.org/standard/om20-2004-06-30/).)\n * OMI - `{ t : 'i', v : 6 }` (where `t` stands for type and `v` for value),\n   and integers may also be stored as strings if desired (e.g., `-6`)\n * OMF - `{ t : 'f', v : -0.521 }`\n * OMSTR - `{ t : 'st', v : 'example' }`\n * OMB - `{ t : 'ba', v : aUint8ArrayHere }`\n * OMS - `{ t : 'sy', n : 'symbolName', cd : 'cd', uri : 'http://...' }`,\n   where the URI is optional\n * OMV - `{ t : 'v', n : 'name' }`\n * OMA - `{ t : 'a', c : [ child, objects, here ] }` (children are the\n   required operator, followed by zero or more operands)\n * OMATTR - rather than wrap things in OMATTR nodes, simply add the\n   attributes object (a mapping from string keys to objects) to the existing\n   object, with 'a' as its key.  To create the string key for an OM symbol,\n   just use its JSON form (fully compact, as created by `JSON.stringify`\n   with one argument).\n * OMBIND - `{ t : 'bi', s : object, v : [ bound, vars ], b : object }`,\n   where `s` stands for the head symbol and `b` for the body\n * OMERR - `{ t : 'e', s : object, c : [ child, nodes, here ] }`, where `s`\n   stands for the head symbol, and `c` can be omitted if empty.\n * No encoding for foreign objects is specified here.\n\n## OpenMath Node class\n\n    OM = class OMNode\n\n### Class (\"static\") methods\n\nThe following class method checks to see if an object is of any one of the\nformats specified above; if so, it returns null, and if not, it returns an\nerror describing why not.  It is recursive, verifying that children are also\nof the correct form.\n\nIt either returns a string, meaning that the object is invalid, and the\nstring contains the reason why, or it returns null, meaning that the object\nis valid.\n\n        @checkJSON : ( object ) ->\n            if object not instanceof Object\n                return \"Expected an object, found #{typeof object}\"\n\nIf the object has attributes, we must verify that their keys are the\nstringified forms of JSON objects representing OpenMath symbols and their\nvalues also pass this same validity test, recursively.\n\n            if object.hasOwnProperty 'a'\n                for own key, value of object.a\n                    try\n                        symbol = JSON.parse key\n                    catch e\n                        return \"Key #{key} invalid JSON\"\n                    if symbol.t isnt 'sy'\n                        return \"Key #{key} is not a symbol\"\n                    if reason = @checkJSON symbol then return reason\n                    if reason = @checkJSON value then return reason\n\nThis function verifies that the object doesn't have any keys beyond those on\nthe list, plus 't' for type and 'a' for attributes.\n\n            checkKeys = ( list... ) ->\n                for key in Object.keys object\n                    if key not in list and key isnt 't' and key isnt 'a'\n                        return \"Key #{key} not valid in object of type\n                            #{object.t}\"\n                null\n\nThis is not nearly the full range of Unicode symbols permitted for\nidentifiers in the OpenMath specification, but is a useful subset for this\nfirst implementation.  See page 14 of [the\nstandard](http://www.openmath.org/standard/om20-2004-06-30/omstd20.pdf) for\nthe exact regular expression.\n\n            identRE =\n                /^[:A-Za-z_\\u0374-\\u03FF][:A-Za-z_\\u0374-\\u03FF.0-9-]*$/\n\nNow we consider each type of object separately.\n\n            switch object.t\n\nIntegers must have t and v keys, and the latter must look like an integer,\nwhether it's actually one or a string doesn't matter.\n\n                when 'i'\n                    if reason = checkKeys 'v' then return reason\n                    if not /^[+-]?[0-9]+$/.test \"#{object.v}\"\n                        return \"Not an integer: #{object.v}\"\n\nFloats must have t and v keys, and the latter must be a number.\n\n                when 'f'\n                    if reason = checkKeys 'v' then return reason\n                    if typeof object.v isnt 'number'\n                        return \"Not a number: #{object.v} of type\n                            #{typeof object.v}\"\n                    if isNaN object.v\n                        return 'OpenMath floats cannot be NaN'\n                    if not isFinite object.v\n                        return 'OpenMath floats must be finite'\n\nStrings must have t and v keys, and the latter must be a string.\n\n                when 'st'\n                    if reason = checkKeys 'v' then return reason\n                    if typeof object.v isnt 'string'\n                        return \"Value for st type was #{typeof object.v},\n                            not string\"\n\nByte Arrays must have t and v keys, the latter of which is a `Uint8Array`.\n\n                when 'ba'\n                    if reason = checkKeys 'v' then return reason\n                    if object.v not instanceof Uint8Array\n                        return \"Value for ba type was not an instance of\n                            Uint8Array\"\n\nSymbols must have t, n, and cd keys, with an optional uri key, all of which\nmust be strings.  The n key (for \"name\") must be a valid identifier, in that\nit must match the regular expression defined above.\n\n                when 'sy'\n                    if reason = checkKeys 'n','cd','uri' then return reason\n                    if typeof object.n isnt 'string'\n                        return \"Name for sy type was #{typeof object.n},\n                            not string\"\n                    if typeof object.cd isnt 'string'\n                        return \"CD for sy type was #{typeof object.cd},\n                            not string\"\n                    if object.uri? and typeof object.uri isnt 'string'\n                        return \"URI for sy type was #{typeof object.uri},\n                            not string\"\n                    if not identRE.test object.n\n                        return \"Invalid identifier as symbol name:\n                            #{object.n}\"\n                    if not identRE.test object.cd\n                        return \"Invalid identifier as symbol CD:\n                            #{object.cd}\"\n\nVariables must have t and n keys, the latter of which must be a valid\nidentifier, matching the same regular expression as above.\n\n                when 'v'\n                    if reason = checkKeys 'n' then return reason\n                    if typeof object.n isnt 'string'\n                        return \"Name for v type was #{typeof object.n},\n                            not string\"\n                    if not identRE.test object.n\n                        return \"Invalid identifier as variable name:\n                            #{object.n}\"\n\nApplications must have t and c keys, the latter of which must be an array of\nobjects that pass this same validity test, applied recursively.  It may not\nbe empty.\n\n                when 'a'\n                    if reason = checkKeys 'c' then return reason\n                    if object.c not instanceof Array\n                        return \"Children of application object was not an\n                            array\"\n                    if object.c.length is 0\n                        return \"Application object must have at least one\n                            child\"\n                    for child in object.c\n                        if reason = @checkJSON child then return reason\n\nBindings must have t, s, v, and b keys, where s is a symbol, v an array of\nvariables, and b any OpenMath node.\n\n                when 'bi'\n                    if reason = checkKeys 's', 'v', 'b' then return reason\n                    if reason = @checkJSON object.s then return reason\n                    if object.s.t isnt 'sy'\n                        return \"Head of a binding must be a symbol\"\n                    if object.v not instanceof Array\n                        return \"In a binding, the v value must be an array\"\n                    for variable in object.v\n                        if reason = @checkJSON variable then return reason\n                        if variable.t isnt 'v'\n                            return \"In a binding, all values in the v array\n                                must have type v\"\n                    if reason = @checkJSON object.b then return reason\n\nErrors must have t, s, and c keys, with s a symbol and c an array of child\nnodes.\n\n                when 'e'\n                    if reason = checkKeys 's', 'c' then return reason\n                    if reason = @checkJSON object.s then return reason\n                    if object.s.t isnt 'sy'\n                        return \"Head of an error must be a symbol\"\n                    if object.c not instanceof Array\n                        return \"In an error, the c key must be an array\"\n                    for child in object.c\n                        if reason = @checkJSON child then return reason\n\nIf the object's type is not on that list, it's not valid.\n\n                else\n                    return \"Invalid type: #{object.t}\"\n\nIf all of the above checks pass then we return null, meaning the object is\nvalid (no errors).\n\n            null\n\nThe following function converts a string encoding of an OpenMath structure\nand creates an instance of `OMNode` for the corresponding structure.\n * If the string contains invalid JSON, this routine will return an\n   error message string rather than an OMNode object.\n * If it contains JSON for a structure that doesn't pass `checkJSON`, above,\n   again, an error message string is returned.\n * Otherwise it adds appropriate parent pointers to the nodes in the\n   resulting tree, then wraps it in an instance of OMNode and returns it.\nThe function can also take an object that has been parsed from such JSON\ntext.\n\n        @decode : ( json ) ->\n            if typeof json is 'string'\n                try json = JSON.parse json catch e then return e.message\n            if reason = @checkJSON json then return reason\n            setParents = ( node ) ->\n                for c in node.c ? [ ] # children, if any\n                    c.p = node\n                    setParents c\n                for v in node.v ? [ ] # bound variables, if any\n                    v.p = node\n                    setParents v\n                for own k, v of node.a ? { } # attribute values, if any\n                    v.p = node\n                    setParents v\n                # head symbol and body object, if any\n                if node.s? then node.s.p = node ; setParents node.s\n                if node.b? then node.b.p = node ; setParents node.b\n            setParents json\n            json.p = null\n            new OMNode json\n\n### Constructor\n\nThe above factory function uses the following constructor.  The constructor\nalso defines several properties for the object, by installing getters for\nthe common attributes type, value, name, cd, uri, symbol, body, children,\nand variables.  These all return undefined if they do not apply to the\ncurrent structure, except children and variables, which return empty arrays\nin that case.\n\n        constructor : ( @tree ) ->\n            Object.defineProperty this, 'parent',\n                get : -> if @tree.p then new OMNode @tree.p else undefined\n            Object.defineProperty this, 'type', get : -> @tree.t\n            Object.defineProperty this, 'value',\n                get : -> if @tree.t isnt 'bi' then @tree.v else undefined\n            Object.defineProperty this, 'name', get : -> @tree.n\n            Object.defineProperty this, 'cd', get : -> @tree.cd\n            Object.defineProperty this, 'uri', get : -> @tree.uri\n            Object.defineProperty this, 'symbol',\n                get : -> if @tree.s then new OMNode @tree.s else undefined\n            Object.defineProperty this, 'body',\n                get : -> if @tree.b then new OMNode @tree.b else undefined\n            Object.defineProperty this, 'children',\n                get : -> new OMNode child for child in @tree.c ? [ ]\n            Object.defineProperty this, 'variables',\n                get : -> if @tree.t is 'bi'\n                    new OMNode variable for variable in @tree.v\n                else\n                    [ ]\n\n### Serialization\n\nUnserializing an `OMNode` object from a string is done by the `decode`\nmethod, above.  Serializing is done by its inverse, here, which simply uses\n`JSON.stringify`, but filters out parent pointers.\n\n        encode : =>\n            JSON.stringify @tree, ( k, v ) ->\n                if k is 'p' then undefined else v\n\n### Copies and equality\n\nTwo instances will often want to be compared for equality, structurally.\nThis is essentially the same activity as comparing equality of two JSON\nstructures, except parent pointers should be ignored so that the recursion\nremains acyclic.\n\nYou can pass a second parameter indicating whether to pay attention to\nattributes in the comparison.  By default it is true, meaning consider all\nattributes.  If it is false, no attributes will be considered.  Other values\nmay be supported in the future.\n\n        equals : ( other, attributes = yes ) =>\n            recur = ( a, b ) ->\n\nIf they are atomically equal, we're done.\n\n                if a is b then return yes\n\nIf they're arrays, ensure they have the same length, type, and contents.\n\n                if a instanceof Array or a instanceof Uint8Array\n                    if ( a instanceof Array ) and ( b not instanceof Array )\n                        return no\n                    if ( a instanceof Uint8Array ) and \\\n                       ( b not instanceof Uint8Array )\n                        return no\n                    if a.length isnt b.length then return no\n                    for element, index in a\n                        if not recur element, b[index] then return no\n                    return yes\n\nOtherwise, they must be objects, with all the same key-value pairs.\n\n                if a not instanceof Object then return no\n                if b not instanceof Object then return no\n                for own key, value of a\n                    if key is 'p' or not attributes and key is 'a'\n                        continue\n                    if not b.hasOwnProperty key then return no\n                    if not recur value, b[key] then return no\n                for own key, value of b\n                    if key is 'p' or not attributes and key is 'a'\n                        continue\n                    if not a.hasOwnProperty key then return no\n                yes\n            recur @tree, other.tree\n\nThere is also a much stricter notion of equality:  Do the two OMNode objects\nactually wrap the same object underneath?  That is, are they pointing to the\nsame tree in memory?  This function can detect that.\n\n        sameObjectAs : ( other ) => @tree is other?.tree\n\nOn a similar note, you may want to create a distinct copy of any given\nOMNode instance.  Here is a method for doing so.\n\n        copy : =>\n            recur = ( tree ) ->\n                result = switch tree.t\n\nIntegers, floats, and strings are easy to copy; just duplicate type and\nvalue.  Variables and symbols are easy for the same reason, but different\natomic members.\n\n                    when 'i', 'f', 'st' then { t : tree.t, v : tree.v }\n                    when 'v' then { t : 'v', n : tree.n }\n                    when 'sy'\n                        result = { t : 'sy', n : tree.n, cd : tree.cd }\n                        if tree.hasOwnProperty 'uri'\n                            result.uri = tree.uri\n                        result\n\nByte arrays require making a copy of the byte array object, which can be\naccomplished with the constructor.\n\n                    when 'ba' then { t : 'ba', v : new Uint8Array tree.v }\n\nFor errors and applications, we copy the children array; for errors we also\ninclude the symbol.\n\n                    when 'e', 'a'\n                        result =\n                            t : tree.t\n                            c : ( recur child for child in tree.c )\n                        if tree.t is 'e' then result.s = recur tree.s\n                        result\n\nLastly, for bindings, we copy each sub-part: symbol, body, variable list.\n\n                    when 'bi'\n                        t : 'bi'\n                        s : recur tree.s\n                        v : ( recur variable for variable in tree.v )\n                        b : recur tree.b\n\nThen no matter what we created, we copy the attributes over as well.\n\n                for own key, value of tree.a ? { }\n                    ( result.a ?= { } )[key] = recur value\n                result\n\nApply the recursive function.\n\n            OMNode.decode recur @tree\n\n### Factory functions\n\nWe provide here functions for creating each type of OMNode, from integer to\nerror.  Each is a \"static\" (class) method, documented separately.  It\nreturns an error message as a string if there was an error, instead of the\ndesired OMNode instance.\n\nThe integer factory function creates an OpenMath integer node, and must be\npassed a single parameter containing either an integer or a string\nrepresentation of an integer, e.g., `OM.integer 100`.\n\n        @integer : ( value ) ->\n            OMNode.decode { t : 'i', v : value }\n\nThe float factory function creates an OpenMath float node, and must be\npassed a single parameter containing a number, e.g., `OM.integer 1.234`,\nand that number cannot be infinite or NaN.\n\n        @float : ( value ) ->\n            OMNode.decode { t : 'f', v : value }\n\nThe string factory function creates an OpenMath string node, and must be\npassed a single parameter containing a string, e.g., `OM.integer 'hi'`.\n\n        @string : ( value ) ->\n            OMNode.decode { t : 'st', v : value }\n\nThe byte array factory function creates an OpenMath byte array node, and\nmust be passed a single parameter that is an instance of `Uint8Array`.\n\n        @bytearray : ( value ) ->\n            OMNode.decode { t : 'ba', v : value }\n\nThe symbol factory function creates an OpenMath symbol node, and must be\npassed two or three parameters, in this order: symbol name (a string),\ncontent dictionary name (a string), and optionally the CD's base URI (a\nstring).\n\n        @symbol : ( name, cd, uri ) ->\n            OMNode.decode if uri?\n                { t : 'sy', n : name, cd : cd, uri : uri }\n            else\n                { t : 'sy', n : name, cd : cd }\n\nThe variable factory function creates an OpenMath variable node, and must be\npassed one parameter, the variable name (a string).\n\n        @variable : ( name ) ->\n            OMNode.decode { t : 'v', n : name }\n\nThe application factory creates an OpenMath application node, and accepts a\nvariable number of arguments, each of which must be either an `OMNode`\ninstance or the JSON object that could function as the tree within such an\ninstance.  `OMNode` instances are copied, objects are used as-is.\n\n        @application : ( args... ) ->\n            result = { t : 'a', c : [ ] }\n            for arg in args\n                result.c.push if arg instanceof OMNode\n                    JSON.parse arg.encode() # copy without parent pointers\n                else\n                    arg\n            OMNode.decode result\n\nThe attribution factory creates an OpenMath node from its first argument,\nand attaches to it the attributes specified by the remaining arguments.\nThose remaining arguments must come in pairs k1, v1, through kn, vn, and\neach ki,vi pair must be an OpenMath symbol node followed by any OpenMath\nnode.  As in the case of applications, such nodes may be JSON objects or\n`OMNode` instances; the former are used as-is and the latter copied.  The\nfirst parameter can also be either a JSON object or an `OMNode` instance,\nand in the latter case it, too, is copied.\n\n        @attribution : ( node, attrs... ) ->\n            if node not instanceof Object\n                return 'Invalid first parameter to attribution'\n            if attrs.length % 2 isnt 0\n                return 'Incomplete key-value pair in attribution'\n            if node instanceof OMNode then node = JSON.parse node.encode()\n            while attrs.length > 0\n                node.a ?= { }\n                key = attrs.shift()\n                key = if key instanceof OMNode\n                    key.encode()\n                else\n                    JSON.stringify key\n                value = attrs.shift()\n                node.a[key] = if value instanceof OMNode\n                    JSON.parse value.encode() # copy without parent pointers\n                else\n                    value\n            OMNode.decode node\n\nThe binding factory functions exactly like the application factory, except\nthat it has restrictions on the types of its arguments.  The first must be a\nsymbol (used as the head of the binding), the last can be any OpenMath node,\nand all those in between must be variables.  Furthermore, there must be at\nleast two arguments, so that there is a head and a body.  Just as in the\ncase of applications, `OMNode` instances are copied, but straight JSON\nobjects are used as-is.\n\n        @binding : ( head, vars..., body ) ->\n            if head not instanceof Object\n                return 'Invalid first parameter to binding'\n            if body not instanceof Object\n                return 'Invalid last parameter to binding'\n            result =\n                t : 'bi'\n                s : if head instanceof OMNode\n                    JSON.parse head.encode()\n                else\n                    head\n                v : [ ]\n                b : if body instanceof OMNode\n                    JSON.parse body.encode()\n                else\n                    body\n            for variable in vars\n                result.v.push if variable instanceof OMNode\n                    JSON.parse variable.encode() # copy w/o parent pointers\n                else\n                    variable\n            OMNode.decode result\n\nThe error factory functions exactly like the application factory, except\nthat it has one restriction on the types of its arguments:  The first must\nbe a symbol.  Just as in the case of applications, `OMNode` instances are\ncopied, but straight JSON objects are used as-is.\n\n        @error : ( head, others... ) ->\n            if head not instanceof Object\n                return 'Invalid first parameter to binding'\n            result =\n                t : 'e'\n                s : if head instanceof OMNode\n                    JSON.parse head.encode()\n                else\n                    head\n                c : [ ]\n            for other in others\n                result.c.push if other instanceof OMNode\n                    JSON.parse other.encode() # copy without parent pointers\n                else\n                    other\n            OMNode.decode result\n\n### Simple encoding and decoding\n\nThe above functions can be used to create OpenMath data structures of\narbitrary complexity and type.  But most use cases can be handled with only\na subset of that full complexity, and we provide the following tools for\ndoing so.\n\n`OMNode.simpleDecode()` takes a string as input (like `OMNode.decode()`\ndoes), but this string is in a much simple form.  Here are the formats it\nsupports.\n * `anyIdentifier` will be treated as a variable.  Examples:\n   * `x`\n   * `thing_7`\n * `ident1.ident2` will be treated as a symbol (CD and name, respectively).\n   Examples:\n   * `arith1.plus`\n   * `transc1.arcsin`\n * any integer will be treated as an integer.  Examples:\n   * -6\n   * 57328074078459027340 (value will be a string, due to size)\n * any float will be treated as a float.  Examples:\n   * 582.53280\n   * -0.00001\n * a string literal enclosed in quotation marks (`\"`) will be treated as a\n   string, but with no support for escape codes, other than `\\\"`.  Examples:\n   * \"this is a string\"\n   * \"\"\n * a string literal enclosed in single quotes (`'`) behaves the same way,\n   escaping only `\\'`\n   * 'this is also a string, ain\\'t it?'\n   * '\"\"'\n * `F(A1,...,An)`, where `F` is any valid form and each `Ai` is as well,\n   is interpreted as the application of `F` to the `Ai` in the order given.\n   Here `n` may be zero.  Examples:\n   * `f(x)`\n   * `transc1.arcsin(arith1.divide(1,2))`\n * `F[A1,...,An]` behaves the same as the previous case, except that the\n   `Ai` entries before `An` must all be variables, and they will be bound;\n   i.e., this yields an OpenMath binding object, not an application object.\n   Examples:\n   * `logic.forall[x,P(x)]`\n   * `foo.lambda[x,f(x,7,\"bar\")]`\nThis syntax does not allow for the expression of OpenMath error objects,\nattributions, symbol URIs, byte arrays, or very large integers.\n\nWe declare the following structure for use in the routine below.\n\n        tokenTypes = [\n            name : 'symbol'\n            pattern : /[:A-Za-z_][:A-Za-z_0-9-]*\\.[:A-Za-z_][:A-Za-z_0-9-]*/\n        ,\n            name : 'variable'\n            pattern : /[:A-Za-z_][:A-Za-z_0-9-]*/\n        ,\n            name : 'float'\n            pattern : /[+-]?(?:[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)/\n        ,\n            name : 'integer'\n            pattern : /[+-]?[0-9]+/\n        ,\n            name : 'string'\n            pattern : /\"(?:[^\"\\\\]|\\\\\"|\\\\\\\\)*\"|'(?:[^'\\\\]|\\\\'|\\\\\\\\)*'/\n        ,\n            name : 'comma'\n            pattern : /,/\n        ,\n            name : 'openParen'\n            pattern : /\\(/\n        ,\n            name : 'closeParen'\n            pattern : /\\)/\n        ,\n            name : 'openBracket'\n            pattern : /\\[/\n        ,\n            name : 'closeBracket'\n            pattern : /\\]/\n        ]\n\nNow the routine itself.\n\n        @simpleDecode = ( input ) ->\n\nEnsure the input is a string.\n\n            if typeof input isnt 'string'\n                return 'Input was not a string'\n\nTokenize it using the above token data.\n\n            tokens = [ ]\n            while input.length > 0\n                originally = input.length\n                for tokenType in tokenTypes\n                    match = tokenType.pattern.exec input\n                    if match? and match.index is 0\n                        tokens.push\n                            type : tokenType.name\n                            text : match[0]\n                        input = input[match[0].length..]\n                if input.length is originally\n                    return \"Could not understand from here: #{input[..10]}\"\n\nParse tokens using two states: one for when an expression is about to start,\nand one for when an expression just ended.  Maintain a stack of expressions\nalready parsed, for forming application and binding expressions.\n\n            state = 'expression about to start'\n            stack = [ ]\n            while tokens.length > 0\n                next = tokens.shift()\n                switch state\n                    when 'expression about to start'\n                        switch next.type\n                            when 'symbol'\n                                halves = next.text.split '.'\n                                stack.unshift\n                                    node :\n                                        OMNode.symbol halves[1], halves[0]\n                            when 'variable'\n                                stack.unshift\n                                    node : OMNode.variable next.text\n                            when 'integer'\n                                int = parseInt next.text\n                                if /\\./.test int then int = next.text\n                                stack.unshift node : OMNode.integer int\n                            when 'float'\n                                stack.unshift\n                                    node : OMNode.float parseFloat next.text\n                            when 'string'\n                                type = next.text[0]\n                                next = next.text[1...-1].replace \\\n                                    RegExp( \"\\\\\\\\#{type}\", 'g' ), type\n                                stack.unshift node : OMNode.string next\n                            else return \"Unexpected #{next.text}\"\n                        state = 'expression ended'\n                    when 'expression ended'\n                        switch next.type\n                            when 'comma'\n                                state = 'expression about to start'\n                            when 'openParen'\n                                stack[0].head = 'application'\n                                if tokens?[0]?.type is 'closeParen'\n                                    tokens.shift()\n                                    stack.unshift\n                                        node : OMNode.application \\\n                                            stack.shift().node\n                                    state = 'expression ended'\n                                else\n                                    state = 'expression about to start'\n                            when 'openBracket'\n                                stack[0].head = 'binding'\n                                state = 'expression about to start'\n                            when 'closeParen'\n                                for expr, index in stack\n                                    if expr.head is 'application' then break\n                                    if expr.head is 'binding'\n                                        return \"Mismatch: [ closed by )\"\n                                if index is stack.length\n                                    return \"Unexpected )\"\n                                children = [ ]\n                                for i in [0..index]\n                                    children.unshift stack.shift().node\n                                stack.unshift\n                                    node : OMNode.application.apply \\\n                                        null, children\n                            when 'closeBracket'\n                                for expr, index in stack\n                                    if expr.head is 'binding' then break\n                                    if expr.head is 'application'\n                                        return \"Mismatch: ( closed by ]\"\n                                if index is stack.length\n                                    return \"Unexpected ]\"\n                                children = [ ]\n                                for i in [0..index]\n                                    children.unshift stack.shift().node\n                                stack.unshift\n                                    node : OMNode.binding.apply \\\n                                        null, children\n                            else return \"Unexpected #{next.text}\"\n                if typeof stack?[0].node is 'string'\n                    return stack[0].node # error in building OMNode\n\nParsing complete so there should be just one node on the stack, the result.\nIf there is more than one, we have an error.\n\n            if stack.length > 1\n                \"Unexpected end of input\"\n            else\n                stack[0].node\n\nThe inverse to the above function is a simple encoding function.  It can\noperate on only a subset of the full complexity of OMNode trees, and thus in\nsome cases it gives results that are not representative of the input.  Here\nare the details:\n * integers, floats, and strings will all be correctly encoded\n * variables without dots in their names will be correctly encoded; those\n   with dots in their names conflict with the naming of symbols in the\n   simple encoding, but will be encoded as their names\n * symbols will be correctly encoded with the exception that any URI will be\n   dropped, and the same issue with dots applies to symbol and CD names\n * byte arrays and errors have no simple encoding, and will thus all be\n   converted to a string containing the words \"byte array\" or \"error,\"\n   respectively\n * all attributions are dropped\n\n        simpleEncode : =>\n            recur = ( tree ) ->\n                switch tree?.t\n                    when 'i', 'f' then \"#{tree.v}\"\n                    when 'v' then tree.n\n                    when 'st' then \"'#{tree.v.replace /'/g, '\\\\\\''}'\"\n                    when 'sy' then \"#{tree.cd}.#{tree.n}\"\n                    when 'ba' then \"'byte array'\"\n                    when 'e' then \"'error'\"\n                    when 'a'\n                        children = ( recur c for c in tree.c )\n                        head = children.shift()\n                        \"#{head}(#{children.join ','})\"\n                    when 'bi'\n                        variables = ( recur v for v in tree.v )\n                        head = recur tree.s\n                        body = recur tree.b\n                        \"#{head}[#{variables.join ','},#{body}]\"\n                    else \"Error: Invalid OpenMath type #{tree?.t}\"\n            recur @tree\n\n### Parent-child relationships\n\nThe functions in this category make, break, or report the relationship of an\nOMNode instance to its parents or children.\n\nThis first function reports where the node is in its parent.  The return\nvalue will be one of five types:\n * a string containing \"c\" followed by a number, as in 'c7' - this means\n   that the node is in it's parent's `children` array, and is at index 7\n * a string containing \"v\" followed by a number, as in 'v0' - this is the\n   same as the previous, but for the parent's `variables` array\n * the string \"b\" - this means that the node is the body and its parent is\n   a binding\n * the string \"s\" - this means that the node is a symbol for its parent,\n   which is either an error or a binding\n * a lengthier string beginning with \"{\" - this is the JSON encoded version\n   of the attribute key for which the node is the corresponding value\n * undefined if none of the above apply (e.g., no parent, or invalid tree\n   structure)\n\n        findInParent : =>\n            if not @parent then return undefined\n            for child, index in @parent.children\n                if @sameObjectAs child then return \"c#{index}\"\n            if @type is 'v'\n                for variable, index in @parent.variables\n                    if @sameObjectAs variable then return \"v#{index}\"\n            if @sameObjectAs @parent.symbol then return 's'\n            if @sameObjectAs @parent.body then return 'b'\n            for own key, value of @parent.tree.a ? { }\n                if @tree is value then return key\n            undefined # should not happen\n\nThe inverse of the previous function takes a string output by that function\nand returns the corresponding child/variables/symbol/body immediately inside\nthis node.  That is, `x.parent.findChild x.findInParent()` will give us back\nthe same tree as `x` itself.  An invalid input will return undefined.\n\n        findChild : ( indexInParent ) =>\n            switch indexInParent[0]\n                when 'c' then @children[parseInt indexInParent[1..]]\n                when 'v' then @variables[parseInt indexInParent[1..]]\n                when 's' then @symbol\n                when 'b' then @body\n                when '{' then @getAttribute OMNode.decode indexInParent\n\nThe `findInParent()` function can be generalized to find a node in any of\nits ancestors, the result being an array of `findInParent()` results as you\nwalk downward from the ancestor to the descendant.  For instance, the first\nbound variable within the second child of an application would have the\naddress `[ 'c1', 'v0' ]` (since indices are zero-based).  The following\nfunction computes the array in question, the node's \"address\" within the\ngiven ancestor.\n\nIf no ancestor is specified, the highest-level one is used.  If a value is\npassed that is not an ancestor of this node, then it is treated as if no\nvalue had been passed.  If this node has no parent, or if this node itself\nis passed as the parameter, then the empty array is returned.\n\n        address : ( inThis ) =>\n            if not @parent or @sameObjectAs inThis then return [ ]\n            @parent.address( inThis ).concat [ @findInParent() ]\n\nThe `address` function has the following inverse, which looks up in an\nancestor node a descendant that has the given address within that ancestor.\nSo, in particular, `x.index y.address( x )` should equal `y`.  Furthermore,\n`x.index [ ]` will always yield `x`.  An invalid input will return\nundefined.\n\n        index : ( address ) =>\n            if address not instanceof Array then return undefined\n            if address.length is 0 then return this\n            @findChild( address[0] )?.index address[1..]\n\nThe following function breaks the relationship of the object with its\nparent.  In some cases, this can invalidate the parent (e.g., by giving a\nbinding or error object no head symbol, or a binding no body, or no bound\nvariables).  If the object has no parent or its position in that parent is\nundefined (as determined by `@findInParent()`) then this does nothing.\n\n        remove : =>\n            if not index = @findInParent() then return\n            switch index[0]\n                when 'c'\n                    @parent.tree.c.splice parseInt( index[1..] ), 1\n                when 'v'\n                    @parent.tree.v.splice parseInt( index[1..] ), 1\n                when 'b' then delete @parent.tree.b\n                when 's' then delete @parent.tree.s\n                when '{' then delete @parent.tree.a[index]\n            delete @tree.p\n\nIt will also be useful in later functions in this class to be able to\nreplace a subtree in-place with a new one.  The following method\naccomplishes this, replacing this object in its context with the parameter.\nThis works whether this tree is a child, variable, head symbol, body, or\nattribute value of its parent.  If this object has no parent, then we make\nno modifications to that parent, since it does not exist.\n\nIn all other cases, the parameter is `remove()`d from its context, and this\nnode, if it has a parent, is `remove()`d from it as well.  Furthermore, this\nOMNode instance becomes a wrapper to the given node instead of its current\ncontents.  The removed node is returned.\n\n        replaceWith : ( other ) =>\n            if @sameObjectAs other then return\n            index = @findInParent()\n\nIf you attempt to replace a binding's or error's head symbol with a\nnon-symbol, this routine does nothing.  If you attempt to replace one of a\nbinding's variables with a non-variable, this routine does nothing.  When\nthis routine does nothing, it returns undefined.\n\n            if index is 's' and other.type isnt 'sy' then return\n            if index?[0] is 'v' and other.type isnt 'v' then return\n            other.remove()\n            original = new OMNode @tree\n            @tree = other.tree\n            switch index?[0]\n                when 'c'\n                    original.parent.tree.c[parseInt index[1..]] = @tree\n                when 'v'\n                    original.parent.tree.v[parseInt index[1..]] = @tree\n                when 'b' then original.parent.tree.b = @tree\n                when 's' then original.parent.tree.s = @tree\n                when '{' then original.parent.tree.a[index] = @tree\n                else return # didn't have a parent\n            @tree.p = original.tree.p\n            delete original.tree.p\n            original\n\n### Attributes\n\nHere we have three functions that let us manipulate attributes without\nworrying about the unpredictable ordering of keys in a JSON stringification\nof an object.\n\nThe first takes an OMNode instance as input and looks up the corresponding\nkey-value pair in this object's attributes, if there is one.  If so, it\nreturns the corresponding value as an OMNode instance.  Otherwise, it\nreturns undefined.\n\nFor efficiency, this considers only the names and CDs of the key when\nsearching.  If that becomes a problem later, it could be changed here in\nthis function, as well as in the two that follow.\n\n        getAttribute : ( keySymbol ) =>\n            if keySymbol not instanceof OMNode then return undefined\n            if keySymbol.type isnt 'sy' then return undefined\n            nameRE = RegExp \"\\\"n\\\":\\\"#{keySymbol.name}\\\"\"\n            cdRE = RegExp \"\\\"cd\\\":\\\"#{keySymbol.cd}\\\"\"\n            for own key, value of @tree.a ? { }\n                if nameRE.test( key ) and cdRE.test( key )\n                    return new OMNode value\n\nThe second takes an OMNode instance as input and looks up the corresponding\nkey-value pair in this object's attributes, if there is one.  If so, it\ndeletes that key-value pair, which includes calling `remove()` on the value.\nOtherwise, it does nothing.\n\nThe same efficiency comments apply to this function as to the previous.\n\n        removeAttribute : ( keySymbol ) =>\n            if keySymbol not instanceof OMNode then return\n            if keySymbol.type isnt 'sy' then return\n            nameRE = RegExp \"\\\"n\\\":\\\"#{keySymbol.name}\\\"\"\n            cdRE = RegExp \"\\\"cd\\\":\\\"#{keySymbol.cd}\\\"\"\n            for own key, value of @tree.a ? { }\n                if nameRE.test( key ) and cdRE.test( key )\n                    ( new OMNode value ).remove()\n                    delete @tree.a[key]\n                    return\n\nThe third and final function of the set takes two OMNode instances as input,\na key and a new value.  It looks up the corresponding key-value pair in this\nobject's attributes, if there is one.  If so, it replaces the original value\nwith the new value, including calling `remove()` on the old value.\nOtherwise, it inserts a new key-value pair corresponding to the two\nparameters.  In either case, `remove()` is called on the new value before it\nis inserted into this tree, in case it is already in another tree.\n\nThe same efficiency comments apply to this function as to the previous.\n\n        setAttribute : ( keySymbol, newValue ) =>\n            if keySymbol not instanceof OMNode or \\\n               newValue not instanceof OMNode then return\n            if keySymbol.type isnt 'sy' then return\n            @removeAttribute keySymbol\n            newValue.remove()\n            ( @tree.a ?= { } )[keySymbol.encode()] = newValue.tree\n            newValue.tree.p = @tree\n\n### Free and bound variables and expressions\n\nThe methods in this section are about variable binding and which expressions\nare free to replace others.  There are also methods that do such\nreplacements.\n\nThis method lists the free variables in an expression.  It returns an array\nof strings, just containing the variables' names.  Variables appearing in\nattributes do not count; only variables appearing as children of\napplications or error nodes, or in the body of a binding expression can\nappear on this list.\n\n        freeVariables : =>\n            switch @type\n                when 'v' then return [ @name ]\n                when 'a', 'c'\n                    result = [ ]\n                    for child in @children\n                        for free in child.freeVariables()\n                            result.push free unless free in result\n                    result\n                when 'bi'\n                    boundByThis = ( v.name for v in @variables )\n                    ( varname for varname in @body.freeVariables() \\\n                        when varname not in boundByThis )\n                else [ ]\n\nThis method computes whether an expression is free by walking up its\nancestor chain and determining whether any of the variables free in the\nexpression are bound further up the ancestor chain.  If you pass an\nancestor as the parameter, then the computation will not look upward beyond\nthat ancestor; the default is to leave the parameter unspecified, meaning\nthat the algorithm should look all the way up the parent chain.\n\n        isFree : ( inThis ) =>\n            freeVariables = @freeVariables()\n            walk = this\n            while walk\n                if walk.type is 'bi'\n                    boundHere = ( v.name for v in walk.variables )\n                    for variable in freeVariables\n                        if variable in boundHere then return no\n                if walk.sameObjectAs inThis then break\n                walk = walk.parent\n            yes\n\nThis method returns true if there is a descendant of this structure that is\nstructurally equivalent to the parameter and, at that point in the tree,\npasses the `isFree` test defined immediately above.  This algorithm only\nlooks downward through children, head symbols, and bodies of binding nodes,\nnot attribute keys or values.\n\nLater it would be easy to add an optional second parameter, `inThis`, which\nwould function like the parameter of the same name to `isFree()`, and would\nbe passed directly along to `isFree()`.  This change would require testing.\n\n        occursFree : ( findThis ) =>\n            if @equals( findThis ) and @isFree() then return yes\n            if @symbol?.equals findThis then return yes\n            if @body?.occursFree findThis then return yes\n            for child in @children\n                if child.occursFree findThis then return yes\n            no\n\nOne subtree A is free to replace another B if no variable free in A becomes\nbound when B is replaced by A.  Because we will be asking whether variables\nare free/bound, we will need to know the ancestor context in which to make\nthose queries.  The default is the highest ancestor, but that default can be\nchanged with the optional final parameter.\n\nNote that this routine also returns false in those cases where it does not\nmake sense to replace the given subtree with this tree based simply on their\ntypes, and not even taking free variables into account.  For example, a\nbinding or error node must have a head symbol, which cannot be replaced with\na non-symbol, and a binding node's variables must not be replaced with\nnon-variables.\n\n        isFreeToReplace : ( subtreeToReplace, inThis ) =>\n            if @sameObjectAs subtreeToReplace then return yes\n            if not subtreeToReplace.parent? then return yes\n            context = subtreeToReplace\n            while context.parent then context = context.parent\n            saved = new OMNode subtreeToReplace.tree\n            if not subtreeToReplace.replaceWith @copy() then return no\n            result = subtreeToReplace.isFree inThis\n            subtreeToReplace.replaceWith saved\n            result\n\nThis method replaces every free occurrence of one expression (original) with\na copy of the another expression (replacement).  The search-and-replace\nrecursion only proceeds through children, head symbols, and bodies of\nbinding nodes, not attribute keys or values.\n\nThe optional third parameter, `inThis`, functions like the parameter of the\nsame name to `isFree()`, is passed directly along to `isFree()`.\n\n        replaceFree : ( original, replacement, inThis ) =>\n            inThis ?= this\n            if @isFree( inThis ) and @equals original\n\nAlthough the implementation here is very similar to the implementation of\n`isFreeToReplace()`, we do not call that function, because it would require\nmaking two copies and doing two replacements; this is more efficient.\n\n                save = new OMNode @tree\n                @replaceWith replacement.copy()\n                if not @isFree inThis then @replaceWith save\n                return\n            @symbol?.replaceFree original, replacement, inThis\n            @body?.replaceFree original, replacement, inThis\n            for variable in @variables\n                variable.replaceFree original, replacement, inThis\n            for child in @children\n                child.replaceFree original, replacement, inThis\n\n### Filtering children and descendants\n\nThe following function returns an array of all children (immediate\nsubexpressions, actually, including head symbols, bound variables, etc.)\nthat pass the given criterion.  If no criterion is given, then all immediate\nsubexpressions are returned.  Order is preserved.\n\nNote that the actual subtrees are returned, not copies thereof.  Any\nmanipulation done to the elements of the result array will therefore impact\nthe original expression.\n\n        childrenSatisfying : ( filter = -> yes ) =>\n            children = @children\n            if @symbol? then children.push @symbol\n            children = children.concat @variables\n            if @body? then children.push @body\n            ( child for child in children when filter child )\n\nThe following function returns an array of all subexpressions (not just\nimmediate ones) that pass the given criterion, in tree order.  If no\ncriterion is given, then all subexpressions are returned.\n\nAs with the previous function, the actual subtrees are returned, not copies\nthereof.  Any manipulation done to the elements of the result array will\ntherefore impact the original expression.\n\n        descendantsSatisfying : ( filter = -> yes ) =>\n            results = [ ]\n            if filter this then results.push this\n            for child in @childrenSatisfying()\n                results = results.concat child.descendantsSatisfying filter\n            results\n\nA simpler function performs the same task as the previous, but does not\nreturn a list of all descendants; it merely returns whether there are any,\nas a boolean.  It is thus more efficient to use this than to run the\nprevious and compare its length to zero.\n\n        hasDescendantSatisfying : ( filter = -> yes ) =>\n            if filter this then return yes\n            for child in @childrenSatisfying()\n                if child.hasDescendantSatisfying filter then return yes\n            no\n\n## Nicknames\n\nHere we copy each of the factory functions to a short version if its own\nname, so that they can be combined in more compact form when creating\nexpressions.  Each short version is simply the first 3 letters of its long\nversion, to make them easy to remember.\n\n    OM.int = OM.integer\n    OM.flo = OM.float\n    OM.str = OM.string\n    OM.byt = OM.bytearray\n    OM.sym = OM.symbol\n    OM.var = OM.variable\n    OM.app = OM.application\n    OM.att = OM.attribution\n    OM.bin = OM.binding\n    OM.err = OM.error\n    OM.simple = OM.simpleDecode\n\n## Creating valid identifiers\n\nBecause OpenMath symbols and variables are restricted to have names that are\nvalid OpenMath identifiers, not all strings can be used as variable or\nsymbol names.  Sometimes, however, one wants to encode an arbitrary string\nas a symbol or variable.  Thus we create the following injection from the\nset of all strings into the set of valid OpenMath identifiers (together with\nits inverse, which goes in the other direction).\n\n    OM.encodeAsIdentifier = ( string ) ->\n        charTo4Digits = ( index ) ->\n            ( '000' + string.charCodeAt( index ).toString( 16 ) ).slice -4\n        result = 'id_'\n        result += charTo4Digits i for i in [0...string.length]\n        result\n    OM.decodeIdentifier = ( ident ) ->\n        result = ''\n        if ident[...3] isnt 'id_' then return result\n        ident = ident[3...]\n        while ident.length > 0\n            result += String.fromCharCode parseInt ident[...4], 16\n            ident = ident[4...]\n        result\n\n## Ancillary utilities\n\nThe functions defined in this section are experimental and incomplete.  They\nare untested, and are just simple implementations present here primarly for\ntheir value to our demo apps.  Complete and tested implementations may come\nlater, if these functions become more important.\n\n### Converting mathematical expressions to XML\n\nThis is an incomplete implementation of the XML encoding for OpenMath trees.\nIt is piecemeal, spotty, and only partially tested, and even those tests\nwere done manually and/or within a demo application, not automated.\n\n    OM::toXML = ->\n        indent = ( text ) -> \"  #{text.replace RegExp( '\\n', 'g' ), '\\n  '}\"\n        switch @type\n            when 'i' then \"<OMI>#{@value}</OMI>\"\n            when 'sy' then \"<OMS cd=\\\"#{@cd}\\\" name=\\\"#{@name}\\\"/>\"\n            when 'v' then \"<OMV name=\\\"#{@name}\\\"/>\"\n            when 'f' then \"<OMF dec=\\\"#{@value}\\\"/>\"\n            when 'st'\n                text = @value.replace /\\&/g, '&amp;'\n                .replace /</g, '&lt;'\n                \"<OMSTR>#{text}</OMSTR>\"\n            when 'a'\n                inside = ( indent c.toXML() for c in @children ).join '\\n'\n                \"<OMA>\\n#{inside}\\n</OMA>\"\n            when 'bi'\n                head = indent @symbol.toXML()\n                vars = ( v.toXML() for v in @variables ).join ''\n                vars = indent \"<OMBVAR>#{vars}</OMBVAR>\"\n                body = indent @body.toXML()\n                \"<OMBIND>\\n#{head}\\n#{vars}\\n#{body}\\n</OMBIND>\"\n            else\n                throw \"Cannot convert this to XML: #{@simpleEncode()}\"\n\n### Evaluating mathematical expressions numerically\n\nThe following is a very limited routine that evaluates mathematical\nexpressions numerically when possible, and returns an explanation of why it\ncould not evaluate them in cases where it could not.  The result is an\nobject with `value` and `message` attributes.\n\nThe `value` attribute is intended to be the result, but may be undefined if\nan error takes place during evaluation (such as division by zero, or many\nother possible mathematical mistakes).  In such cases, the `message`\nattribute will explain what went wrong.  It may be a newline-separated list\nof problems.  Even when the `value` exists, the `message` attribute may be\nnonempty, containing warnings such as when using decimal approximations to\nreal numbers.\n\n    OM::evaluate = ->\n        call = ( func, indices... ) =>\n            message = undefined\n            args = [ ]\n            for index in indices\n                arg = @children[index].evaluate()\n                if not arg.value? then return arg\n                if arg.message?\n                    if not message? then message = '' else message += '\\n'\n                    message += arg.message\n                args.push arg.value\n            try\n                value = func args...\n            catch e\n                if not message? then message = '' else message += '\\n'\n                message += e.message\n            value : value\n            message : message\n        result = switch @type\n            when 'i', 'f' then value : new Number @value\n            when 'st', 'ba' then value : @value\n            when 'v' then switch @name\n                when '\\u03c0' # pi\n                    value : Math.PI\n                    message : 'The actual value of \\u03c0 has been rounded.'\n                when 'e'\n                    value : Math.exp 1\n                    message : 'The actual value of e has been rounded.'\n            when 'sy' then switch @simpleEncode()\n                when 'units.degrees'\n                    value : Math.PI/180\n                    message : 'Converting to degrees used an\n                        approximation of \\u03c0.' # that is, pi\n                when 'units.percent' then value : 0.01\n                when 'units.dollars'\n                    value : 1\n                    message : 'Dollar units were dropped'\n            when 'a' then switch @children[0].simpleEncode()\n                when 'arith1.plus' then call ( ( a, b ) -> a + b ), 1, 2\n                when 'arith1.minus' then call ( ( a, b ) -> a - b ), 1, 2\n                when 'arith1.times' then call ( ( a, b ) -> a * b ), 1, 2\n                when 'arith1.divide' then call ( ( a, b ) -> a / b ), 1, 2\n                when 'arith1.power' then call Math.pow, 1, 2\n                when 'arith1.root'\n                    call ( ( a, b ) -> Math.pow b, 1/a ), 1, 2\n                when 'arith1.abs' then call Math.abs, 1\n                when 'arith1.unary_minus' then call ( ( a ) -> -a ), 1\n                when 'relation1.eq' then call ( ( a, b ) -> a is b ), 1, 2\n                when 'relation1.approx'\n                    tmp = call ( ( a, b ) -> Math.abs( a - b ) < 0.01 ),\n                        1, 2\n                    if ( tmp.message ?= '' ).length then tmp.message += '\\n'\n                    tmp.message += 'Values were rounded to two decimal\n                        places for approximate comparison.'\n                    tmp\n                when 'relation1.neq'\n                    call ( ( a, b ) -> a isnt b ), 1, 2\n                when 'relation1.lt' then call ( ( a, b ) -> a < b ), 1, 2\n                when 'relation1.gt' then call ( ( a, b ) -> a > b ), 1, 2\n                when 'relation1.le' then call ( ( a, b ) -> a <= b ), 1, 2\n                when 'relation1.ge' then call ( ( a, b ) -> a >= b ), 1, 2\n                when 'logic1.not' then call ( ( a ) -> not a ), 1\n                when 'transc1.sin' then call Math.sin, 1\n                when 'transc1.cos' then call Math.cos, 1\n                when 'transc1.tan' then call Math.tan, 1\n                when 'transc1.cot' then call ( ( a ) -> 1/Math.tan(a) ), 1\n                when 'transc1.sec' then call ( ( a ) -> 1/Math.cos(a) ), 1\n                when 'transc1.csc' then call ( ( a ) -> 1/Math.sin(a) ), 1\n                when 'transc1.arcsin' then call Math.asin, 1\n                when 'transc1.arccos' then call Math.acos, 1\n                when 'transc1.arctan' then call Math.atan, 1\n                when 'transc1.arccot'\n                    call ( ( a ) -> Math.atan 1/a ), 1\n                when 'transc1.arcsec'\n                    call ( ( a ) -> Math.acos 1/a ), 1\n                when 'transc1.arccsc'\n                    call ( ( a ) -> Math.asin 1/a ), 1\n                when 'transc1.ln' then call Math.log, 1\n                when 'transc1.log' then call ( base, arg ) ->\n                    Math.log( arg ) / Math.log( base )\n                , 1, 2\n                when 'integer1.factorial'\n                    call ( a ) ->\n                        if a <= 1 then return 1\n                        if a >= 20 then return Infinity\n                        result = 1\n                        result *= i for i in [1..a|0]\n                        result\n                    , 1\n                # Maybe later I will come back and implement these, but this\n                # is just a demo app, so there is no need to get fancy.\n                # when 'arith1.sum'\n                # when 'calculus1.int'\n                # when 'calculus1.defint'\n                # when 'limit1.limit'\n        result ?= value : undefined\n        if typeof result.value is 'undefined'\n            result.message = \"Could not evaluate #{@simpleEncode()}\"\n        # console.log \"#{node.simpleEncode()} --> #{JSON.stringify result}\"\n        result\n\nThe following line ensures that this file works in Node.js, for testing.\n\n    if exports? then exports.OMNode = exports.OM = OM\n"]}