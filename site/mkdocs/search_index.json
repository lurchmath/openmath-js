{
    "docs": [
        {
            "location": "/", 
            "text": "OpenMath.js Documentation\n\n\nGet started now\n\n\nTo import this code via a CDN or \nnpm\n, check out the \nAPI Reference\nPage\n.\n\n\nBackground\n\n\nOpenMath\n is a data storage standard for\nmeaningful mathematics.  Rather than encoding the appearance of the\nmathematics (like \nLaTeX\n does, for\ninstance), it encodes the meaning of the mathematics (similar to \nContent\nMathML\n).  You can\nread its latest standard\n\nhere\n.\n\n\nMore Information\n\n\nThe following additional information is available in this documentation.\n\n\n\n\nWork Done\n - what the code in this repository can do, and\n   what it cannot do\n\n\nSource Code\n - see the source and/or import it into your\n   own project\n\n\nAPI Reference\n - how to use the various functions and\n   objects provided", 
            "title": "Home"
        }, 
        {
            "location": "/#openmathjs-documentation", 
            "text": "", 
            "title": "OpenMath.js Documentation"
        }, 
        {
            "location": "/#get-started-now", 
            "text": "To import this code via a CDN or  npm , check out the  API Reference\nPage .", 
            "title": "Get started now"
        }, 
        {
            "location": "/#background", 
            "text": "OpenMath  is a data storage standard for\nmeaningful mathematics.  Rather than encoding the appearance of the\nmathematics (like  LaTeX  does, for\ninstance), it encodes the meaning of the mathematics (similar to  Content\nMathML ).  You can\nread its latest standard here .", 
            "title": "Background"
        }, 
        {
            "location": "/#more-information", 
            "text": "The following additional information is available in this documentation.   Work Done  - what the code in this repository can do, and\n   what it cannot do  Source Code  - see the source and/or import it into your\n   own project  API Reference  - how to use the various functions and\n   objects provided", 
            "title": "More Information"
        }, 
        {
            "location": "/source-code/", 
            "text": "Source Code\n\n\nReading the source\n\n\nThe code in \nthe repository\n\nresides in \none\nfile\n,\nwritten in \nLiterate CoffeeScript\n.\n\n\nChanging the source\n\n\nIf you don't like that language, you can always compile it directly to\nJavaScript with the following command.\n\n\ncoffee --compile openmath.litcoffee\n\n\n\n\nThis assumes that you've \ninstalled\nCoffeeScript\n and have the \nsource\nfile\n\naccessible.\n\n\nImporting the source\n\n\nTo import the source into your project, you can include it directly from\nGitHub (using \nRawGit\n) at \nthis\nURL\n.\nThere is a source map file in the same folder; see\n\nhere\n.", 
            "title": "Source"
        }, 
        {
            "location": "/source-code/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/source-code/#reading-the-source", 
            "text": "The code in  the repository \nresides in  one\nfile ,\nwritten in  Literate CoffeeScript .", 
            "title": "Reading the source"
        }, 
        {
            "location": "/source-code/#changing-the-source", 
            "text": "If you don't like that language, you can always compile it directly to\nJavaScript with the following command.  coffee --compile openmath.litcoffee  This assumes that you've  installed\nCoffeeScript  and have the  source\nfile \naccessible.", 
            "title": "Changing the source"
        }, 
        {
            "location": "/source-code/#importing-the-source", 
            "text": "To import the source into your project, you can include it directly from\nGitHub (using  RawGit ) at  this\nURL .\nThere is a source map file in the same folder; see here .", 
            "title": "Importing the source"
        }, 
        {
            "location": "/work-done/", 
            "text": "Work Done\n\n\nThis repository implements a portion of \nthe OpenMath 2.0\nstandard\n in JavaScript.\n(For details, you may want to refer to \nthe API\nReference\n.)\n\n\nIn particular, the following pieces have been implemented:\n\n\n\n\nAll types of OpenMath objects except for \nOMFOREIGN\n\n\nSerialization to/deserialization from a simple JSON encoding\n\n\nSerialization to the standard XML encoding\n\n\n\n\nThe following pieces have not been implemented:\n\n\n\n\nDeserialization from the standard XML encoding\n\n\nThe standard binary encoding\n\n\nOMFOREIGN\n objects\n\n\nOnly a subset of the range of Unicode characters valid in OpenMath\n   identifiers is in use in this code; see the \nidentRE\n regular expression\n   used in \nthis function\n\n\n\n\nFuthermore, the following features have been added, above and beyond the\nrequirements of the standard:\n\n\n\n\nDeep copying OpenMath objects and comparing them for structural equality\n\n\nSerialization to/deserialization from a simple prefix notation string\n   encoding useful for convenience (e.g., \nf(x)\n means what you'd think)\n\n\nRoutines for indexing and addressing child or descendant notes within an\n   OpenMath tree structure\n\n\nRoutines for editing an OpenMath tree structure by inserting, removing,\n   or replacing subtrees with others\n\n\nRoutines for finding free/bound variables, and testing whether an\n   expression is free to replace a variable, and performing said replacement\n\n\nFiltering children/descendants by a given predicate\n\n\nEvaluating simple mathematical expressions numerically\n\n\n\n\nTo see how to use these features, check out \nthe API\nReference\n.", 
            "title": "Work"
        }, 
        {
            "location": "/work-done/#work-done", 
            "text": "This repository implements a portion of  the OpenMath 2.0\nstandard  in JavaScript.\n(For details, you may want to refer to  the API\nReference .)  In particular, the following pieces have been implemented:   All types of OpenMath objects except for  OMFOREIGN  Serialization to/deserialization from a simple JSON encoding  Serialization to the standard XML encoding   The following pieces have not been implemented:   Deserialization from the standard XML encoding  The standard binary encoding  OMFOREIGN  objects  Only a subset of the range of Unicode characters valid in OpenMath\n   identifiers is in use in this code; see the  identRE  regular expression\n   used in  this function   Futhermore, the following features have been added, above and beyond the\nrequirements of the standard:   Deep copying OpenMath objects and comparing them for structural equality  Serialization to/deserialization from a simple prefix notation string\n   encoding useful for convenience (e.g.,  f(x)  means what you'd think)  Routines for indexing and addressing child or descendant notes within an\n   OpenMath tree structure  Routines for editing an OpenMath tree structure by inserting, removing,\n   or replacing subtrees with others  Routines for finding free/bound variables, and testing whether an\n   expression is free to replace a variable, and performing said replacement  Filtering children/descendants by a given predicate  Evaluating simple mathematical expressions numerically   To see how to use these features, check out  the API\nReference .", 
            "title": "Work Done"
        }, 
        {
            "location": "/api-reference/", 
            "text": "API Reference\n\n\nGetting started\n\n\nIn the browser\n\n\nImport the minified JavaScript, which you can \ndownload from our repository\ndirectly\n\nor import with the following one-liner from \nRawGit\n, a\nfree CDN.\n\n\nscript src='https://cdn.rawgit.com/lurchmath/openmath-js/84f93b7c/openmath.js'\n/script\n\n\n\n\n\nFrom the command line\n\n\nOr install this package into your project the usual way:\n\n\nnpm install openmath-js\n\n\n\n\nThen within any of your modules, import it as follows.\n\n\nOM = require( \nopenmath-js\n ).OM;\n\n\n\n\nAfter that, any of the example code snippets in this documentation should\nfunction as-is.\n\n\nCreating OpenMath objects\n\n\nThe prototype for OpenMath data structures (that is, expression trees) is\nnamed \nOMNode\n in the global namespace (the browser \nwindow\n) and is also\nnamed \nOM\n for convenience; they are the same object.  It is defined as a\nCoffeeScript class, which translates to a JavaScript prototype.\n\n\nRather than use its constructor, there are a number of factory functions\nthat create \nOM\n instances, as follows.\n\n\n\n\nOM.integer(i)\n creates a new OpenMath integer object from the given\n   JavaScript integer \ni\n.  If you want to store a big integer, pass it as\n   a string instead of an integer, as in \nOM.integer('583257320489234290')\n.\n\n\nOM.float(f)\n creates a new OpenMath float object from the given\n   JavaScript number \nf\n which cannot be infinite or NaN\n\n\nOM.string(s)\n creates a new OpenMath string object from the given\n   JavaScript string \ns\n\n\nOM.bytearray(a)\n creates a new OpenMath bytearray object from the given\n   JavaScript Uint8Array \na\n\n\nOM.symbol(name,cd[,uri])\n creates a new OpenMath symbol with the given\n   name (\nname\n) and content dictionary (\ncd\n), which are both strings.  An\n   optional base \nuri\n can also be passed.\n\n\nOM.variable(x)\n creates a new OpenMath variable whose name is given in\n   the string \nx\n\n\nOM.application(c1,c2,...,cn)\n creates a new OpenMath application whose\n   children are the \nOM\n instances \nc1\n through \ncn\n.  This represents an\n   application of \nc1\n as a function to the arguments \nc2\n through \ncn\n,\n   where n may be 1.  Note that this makes copies of all the children given\n   to it, rather than removing them from their current contexts.  This\n   allows the function to be called on the same argument several times, for\n   instance.\n\n\nOM.attribution(x,k1,v1,k2,v2,...,kn,vn)\n creates a copy of the \nOM\n\n   instance \nx\n with new attribute pairs added.  Each (\nki\n,\nvi\n) pair is a\n   key-value pair, in which \nki\n must be an OpenMath symbol (an \nOM\n\n   instance) and each \nvi\n must be any \nOM\n instance.\n\n\nOM.binding(h,v1,v2,...,vn,b)\n creates a new OpenMath binding in which\n   the head symbol \nh\n (which must be an OpenMath symbol node, an \nOM\n\n   instance) binds the variables \nv1\n through \nvn\n (which must be OpenMath\n   variable nodes, also \nOM\n instances) in the body \nb\n (which can be any\n   \nOM\n instance).\n\n\nOM.error(s,c1,c2,...,cn)\n creates a new OpenMath error object in which\n   \ns\n is the head symbol (an \nOM\n instance representing an OpenMath symbol)\n   and there are zero or more other children \nc1\n through \ncn\n that can be\n   any \nOM\n instances\n\n\n\n\nExample use:\n\n\n\nplus = OM.symbol( 'plus', 'arith1' );\narg1 = OM.variable( 'x' );\narg2 = OM.integer( 5 );\nOM.application( plus, arg1, arg2 ).toXML(); // gives XML encoding for x+5\n\n\n\n\nBecause the above method can easily become annoyingly lengthy, we also\nprovide a shorthand for writing OpenMath expressions as strings and having\nthem parsed in a convenient way.  Full details are covered in \nthe source\ncode documentation\nhere\n.\nIt is called \"simple encoding and decoding,\" and you can create new \nOM\n\ninstances from that encoding with the following function.\n\n\n\n\nOM.simpleDecode(string)\n creates a new \nOM\n instance decoded from the\n   given string.  If your input is invalid (not a string, or a string not\n   containing a valid simple encoding) then the return value will be a\n   string error message, rather than an \nOM\n instance.\n\n\n\n\nExample usage:\n\n\n\nOM.simpleDecode( 'plus.arith1(x,5)' ).toXML();\n\n\n\n\nEach of the functions in this section have nicknames.  For each factory\nfunction given above, it has a three-letter nickname to help you write\nshorter code that builds OpenMath tree structures.  The nicknames are all in\nthe \nOM\n namespace, and include \nint\n, \nflo\n, \nstr\n, \nbyt\n, \nsym\n, \nvar\n,\n\napp\n, \natt\n, \nbin\n, and \nerr\n.  Thus, for instance, you can write the\nfollowing code to build a valid OpenMath expression.\n\n\n\nOM.app( OM.sym( 'plus', 'arith1' ), OM.var( 'x' ), OM.int( 5 ) ).toXML();\n\n\n\n\nFinally, the \nsimpleDecode\n function also has the nickname \nsimple\n, so the\nmost compact form is the following.\n\n\n\nOM.simple( 'plus.arith1(x,5)' ).toXML();\n\n\n\n\nThe \nOM\n objects are just wrappers around JSON tree structures that provide\nmethods for interacting with those tree structures.  You can get access to\nthe tree structur itself with \nmyInstance.tree\n.  It is not quite JSON,\nbecause it has circular references, as children nodes point to their parent\nnodes, but it is close to JSON.\n\n\nThe specification for how OpenMath expressions are stored as JSON trees is\ngiven \nat the top of the source code documentation\n, should you need it.  The following methods are\navailable for working with such structures, but these are rarely used by the\nclient, and are mostly for internal purposes.\n\n\n\n\nOM.checkJSON(jsonObject)\n returns \nnull\n if the object is valid JSON\n   that represents and OpenMath data structure, and thus could be wrapped in\n   an \nOM\n instance, or a string error message if it is not\n\n\nOM.decode(jsonObject)\n creates an \nOM\n instance by wrapping the given\n   object in an \nOM\n object, if possible, or throws an error if\n   \nOM.checkJSON\n fails on the given input\n\n\nOM.decode(string)\n parses the string as JSON and then calls the previous\n   function.\n\n\nOM(tree)\n creates a new \nOM\n instance wrapping the given JSON tree; this\n   is the same as \nOM.decode\n, but more compact.  Note that you can thus get\n   two instances that refer to the same internal data via\n   \nOM(otherInstance.tree)\n.\n\n\n\n\nWriting/saving OpenMath objects\n\n\n\n\ninstance.encode()\n is the inverse of \nOM.decode()\n, and yields a JSON\n   string useful for serializing instances in a compact way\n\n\ninstance.simpleEncode()\n is the inverse of \nOM.simpleDecode()\n, and\n   converts instances into the simple encoding mentioned above.  Note that\n   it does not support errors, byte arrays, or attributions.\n\n\ninstance.toXML()\n yields the XML encoding defined in \nthe OpenMath\n   standard\n.\n\n\n\n\nProperties of OpenMath Objects\n\n\n\n\ninstance.type\n yields the type of an \nOM\n instance, a string containing\n   just one or two letters, one of i, f, st, ba, sy, v, a, bi, e, which mean\n   integer, float, string, bytearray, symbol, variable, application,\n   binding, and error, respectively.  These come directly from the JSON\n   encoding documented \nhere\n.\n\n\ninstance.value\n yields the value of those atomic types that have one, as\n   an atomic JavaScript datum.  Integers and floats yield a JavaScript\n   number, strings yield a JavaScript string, and bytearrays yield a\n   JavaScript UInt8Array.  This property is undefined in all other cases.\n\n\ninstance.name\n yields the string name of a variable or symbol, and is\n   undefined in all other cases.\n\n\ninstance.cd\n yields the content dictionary of a symbol, and is\n   undefined in all other cases.\n\n\ninstance.uri\n yields the base URI of a symbol, if one was provided, and\n   is undefined in all other cases.\n\n\ninstance.symbol\n yields the head symbol for a binding or error object,\n   and is undefined in all other cases.\n\n\ninstance.body\n yields the body of a binding object, and is undefined in\n   all other cases.\n\n\ninstance.children\n yields a JavaScript array containing the child nodes\n   for application or error objects, and is an empty array in all other\n   cases.  It may be an empty array in the case of error objects as well,\n   if they have only a head symbol.\n\n\ninstance.variables\n yields the list of variables bound by a binding\n   object, as a JavaScript array, and is undefined in all other cases.\n\n\n\n\nNote that each of these properties is actually produced by a getter\nfunction, and thus is not always as efficient as you might think.  For\ninstance, you may not wish to write loops like this:\n\n\nfor ( var i = 0 ; i \n anOMinstance.children.length ; i++ )\n    process( anOMinstance.children[i] ); // calls getter many times\n\n\n\n\nRather, you might do better with a loop like this:\n\n\nfor ( var i = 0, ch = anOMinstance.children ; i \n ch.length ; i++ )\n    process( ch[i] ); // doesn't call getter at all on this line\n\n\n\n\nTree-Related Functions\n\n\nAs mentioned at the end of \nthe first section\n,\nit is possible to create two different \nOM\n instances that refer to the same\ninternal tree structure.  And as mentioned immediately above, calling\n\ninstance.children[i]\n produces a new instance each time you call it.\nThus \ninstance.children[0]\n and \ninstance.children[0]\n will refer to the\nsame internal JSON structure, but will be different \nOM\n instances.  We can\nthus check equality in two ways.\n\n\n\n\ninstance.sameObjectAs(otherInstance)\n asks whether two \nOM\n instances\n   refer to the same internal JSON data, the same node in the same tree.\n\n\ninstance.equals(other[,checkAttributes])\n compares structural equality\n   only, and does not care whether the two instances are the same tree.  It\n   includes attributes in the comparison if and only if the second argument\n   is set to true, which is its default.\n\n\ninstance.copy()\n makes a structural deep copy of an \nOM\n instance.\n\n\n\n\nExamples:\n\n\n\nA = OM.application( OM.variable( 'f', OM.integer( 3 ) ) ); // f(3)\nB = A.copy(); // deep copy\nC = A.children[0]; // builds a new OM instance for the f\nD = A.children[0]; // does the same thing again\nconsole.log( A.equals( B ) ); // true\nconsole.log( A.sameObjectAs( B ) ); // false\nconsole.log( A == B ); // false\nconsole.log( C.equals( D ) ); // true\nconsole.log( C.sameObjectAs( D ) ); // true\nconsole.log( C == D ); // false\n\n\n\n\nYou can also modify tree structures as follows.\n\n\n\n\ninstance.remove()\n returns no value, but removes the instance from its\n   parent tree, if that does not break the parent tree's validity.  If it\n   does, this function takes no action.  For instance, you cannot remove\n   the head symbol from a binding or error structure.\n\n\ninstance.replaceWith(other)\n replaces the instance in its parent\n   structure with the given other \nOM\n object, if the resulting tree would\n   be valid, or does nothing otherwise.  The original is returned on\n   success, and undefined is returned on failure.\n\n\ninstance.getAttribute(keySymbol)\n returns the corresponding value for\n   the given key symbol (an \nOM\n instance) in the instance's attributes, if\n   there is one, or undefined if there is not.\n\n\ninstance.setAttribute(keySymbol,value)\n adds or changes an attribute on\n   the instance.  The key symbol must be an \nOM\n symbol instance, and the\n   value must be any \nOM\n instance.\n\n\n\n\nSearching OpenMath Trees\n\n\nWe have devised a way for indexing and addressing children and descendants\nwithin parent/ancestor trees, and the following functions use that\nconvention.  You can read about the indexing/addressing convention \nin the\nsource code documentation here\n.\n\n\n\n\ninstance.findInParent()\n returns a single index of the form cn/vn/b/s,\n    or a JSON attribute key, or undefined if the instance has no parent, as\n    per the indexing scheme linked to above.  It returns undefined if there\n    is no such child.\n\n\ninstance.findChild(indexString)\n is the inverse of the previous, in that\n   it takes as input a string that the previous might give as output, and\n   finds the corresponding child tree by that index.\n\n\n\n\nExample:\n\n\n\nA = OM.application( OM.variable( 'print' ),\n                        OM.string( 'Hello' ), OM.string( 'World' ) );\nstr1 = A.children[1]; // zero-based\nconsole.log( str1.value ); // \"Hello\"\nindex = str1.findInParent();\nconsole.log( index ); // \"c1\"\nchild = A.findChild( index );\nconsole.log( child.sameObjectAs( str1 ) ); // true\n\n\n\n\n\n\ninstance.address(inThisAncestor)\n is a generalization of \nindexInParent\n\n   to arbitrary depth.  It returns an array of indices that one would need\n   to follow, as a path, to walk from the given ancestor node, down through\n   the tree, to reach this instance.  If no ancestor is given (or a\n   non-ancestor is given) then the topmost ancestor is used instead.\n\n\ninstance.index(indexArray)\n is the inverse of the previous function,\n   taking an array of indices and walking that path into its descendants,\n   returning the resulting subtree, or undefined if one or more of the steps\n   were invalid.\n\n\n\n\nExamples:\n\n\n\ndeepTree = OM.simple( 'arith1.plus(f(g(x,y)),h(k(z)))' );\ndescendant = deepTree.index( [ 'c1', 'c1', 'c2' ] );\nconsole.log( descendant.name ); // \"y\"\nconsole.log( descendant.address( deepTree ) ); // c1,c1,c2\nconsole.log( descendant.address( deepTree.children[1] ) ); // c1,c2\n\n\n\n\nYou can filter children or descendants by predicates.\n\n\n\n\ninstance.childrenSatisfying(P)\n returns an array of all immediate\n   children c for which P(c) returns true.  This array may be empty.  For\n   the purposes of this function, immediate children include not only what\n   is returned by \ninstance.children\n, but also head symbols of bindings and\n   errors, and bodies of bindings.\n\n\ninstance.descendantsSatisfying(P)\n is the same as the previous, but\n   considers indirect descendants as well.  Note that original subtrees are\n   returned, not copies, so modifying them will change the original\n   instance.\n\n\ninstance.hasDescendantsSatisfying(P)\n returns true or false, equal to\n   calling \ninstance.descendantsSatisfying(P).length \n 0\n, except this is\n   faster because it can stop searching once it has found one.\n\n\n\n\nFree and Bound Variables\n\n\nMany applications of OpenMath relate to logic and/or programming, in which\nvariable binding and substitutin plays a critical role.  The following\nfunctions make it easy to ask questions and perform the most common\noperations related to variable binding and substitution.\n\n\n\n\ninstance.freeVariables()\n returns and array of free variable names, as\n   strings, that appear anywhere as descendants of the instance.  Each name\n   is only reported once, even if it occurs many times.  This does not recur\n   into attributes or error children.\n\n\ninstance.isFree(inThisAncestor)\n returns true if all variables free in\n   the instance are free in the given ancestor.  An invalid (or omitted)\n   ancestor causes the routine to use the top-most ancestor as well.  If any\n   variable free in the instance is not free in the ancestor, return false.\n\n\ninstance.occursFree(other)\n returns true if there exists a descendant of\n   the instance that's structurally equivalent to \nother\n and that is free\n   where it occurs in the given instance, or returns false if there is not.\n\n\ninstance.isFreeToReplace(subtree,inThisAncestor)\n returns true if\n   replacing the given subtree with the given instance would make any\n   variables free in the instance become bound in the given ancestor.  As\n   before, an invalid or omitted ancestor will use the topmost ancestor of\n   the subtree instead.\n\n\ninstance.replaceFree(original,replacement,inThisAncestor)\n recursively\n   searches through all descendants D of the instance that are structurally\n   equiavlent to the given original, and whenever\n   \nreplacement.isFreeToReplace(D,inThisAncestor)\n yields true, call\n   \nD.replaceWith(replacement)\n.  It does not recur into attributes.\n\n\n\n\nMiscellany\n\n\nSometimes it is useful to be able to take any JavaScript string and convert\nit into a string that could be used as a valid OpenMath identifier (such as\na variable or symbol name).  Because only a subset of Unicode is permitted,\nwe provide an injection (although not a very compact one) from all strings\ninto the set of strings accepted as valid OpenMath identifiers.  The range\nof the function is strings of the form \"id_[many decimal digits here]\".\n\n\n\n\nOM.encodeAsIdentifier(anyString)\n performs the encoding\n\n\nOM.decodeIdentifier(encodedString)\n inverts the previous function\n\n\n\n\nExample:\n\n\n\nconsole.log( OM.encodeAsIdentifier( '#$\n&\n@' ) ); // id_0023002400260040\nconsole.log( OM.decodeIdentifier( \"id_0023002400260040\" ) ); // #$\n&\n@\n\n\n\n\nSome applications find it useful to be able to evaluate simple numerical\nOpenMath expressions.\n\n\n\n\ninstance.evaluate()\n attempts to evaluate a numerical expression that\n   uses the basic operations of arithmetic, powers, roots, trigonometry,\n   pi, e, and a few other simple concepts.  It returns a JavaScript object\n   with two members, \nvalue\n contains the numerical value (if one was able\n   to be computed) and \nmessage\n is a string that may contain some details,\n   such as when rounding needed to occur.\n\n\n\n\nExample:\n\n\n\nconsole.log( OM.simple( 'transc1.cos(0)' ).evaluate() ); // 1\nconsole.log( OM.simple( 'f(x)' ).evaluate() ); // error message\nconsole.log( OM.simple( 'e' ).evaluate() ); // 2.71828... w/rounding message\n\n\n\n\n\n\n\n\nvar elements = document.getElementsByClassName( 'runnable-example' );\nfor ( var i = 0 ; i < elements.length ; i++ ) {\n    var source = elements[i].textContent;\n    elements[i].textContent = '';\n    var notebook = RunKit.createNotebook( {\n        element: elements[i],\n        source: source,\n        preamble: 'OM = require( \"openmath-js\" ).OM;'\n    } );\n}", 
            "title": "Reference"
        }, 
        {
            "location": "/api-reference/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/api-reference/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/api-reference/#in-the-browser", 
            "text": "Import the minified JavaScript, which you can  download from our repository\ndirectly \nor import with the following one-liner from  RawGit , a\nfree CDN.  script src='https://cdn.rawgit.com/lurchmath/openmath-js/84f93b7c/openmath.js' /script", 
            "title": "In the browser"
        }, 
        {
            "location": "/api-reference/#from-the-command-line", 
            "text": "Or install this package into your project the usual way:  npm install openmath-js  Then within any of your modules, import it as follows.  OM = require(  openmath-js  ).OM;  After that, any of the example code snippets in this documentation should\nfunction as-is.", 
            "title": "From the command line"
        }, 
        {
            "location": "/api-reference/#creating-openmath-objects", 
            "text": "The prototype for OpenMath data structures (that is, expression trees) is\nnamed  OMNode  in the global namespace (the browser  window ) and is also\nnamed  OM  for convenience; they are the same object.  It is defined as a\nCoffeeScript class, which translates to a JavaScript prototype.  Rather than use its constructor, there are a number of factory functions\nthat create  OM  instances, as follows.   OM.integer(i)  creates a new OpenMath integer object from the given\n   JavaScript integer  i .  If you want to store a big integer, pass it as\n   a string instead of an integer, as in  OM.integer('583257320489234290') .  OM.float(f)  creates a new OpenMath float object from the given\n   JavaScript number  f  which cannot be infinite or NaN  OM.string(s)  creates a new OpenMath string object from the given\n   JavaScript string  s  OM.bytearray(a)  creates a new OpenMath bytearray object from the given\n   JavaScript Uint8Array  a  OM.symbol(name,cd[,uri])  creates a new OpenMath symbol with the given\n   name ( name ) and content dictionary ( cd ), which are both strings.  An\n   optional base  uri  can also be passed.  OM.variable(x)  creates a new OpenMath variable whose name is given in\n   the string  x  OM.application(c1,c2,...,cn)  creates a new OpenMath application whose\n   children are the  OM  instances  c1  through  cn .  This represents an\n   application of  c1  as a function to the arguments  c2  through  cn ,\n   where n may be 1.  Note that this makes copies of all the children given\n   to it, rather than removing them from their current contexts.  This\n   allows the function to be called on the same argument several times, for\n   instance.  OM.attribution(x,k1,v1,k2,v2,...,kn,vn)  creates a copy of the  OM \n   instance  x  with new attribute pairs added.  Each ( ki , vi ) pair is a\n   key-value pair, in which  ki  must be an OpenMath symbol (an  OM \n   instance) and each  vi  must be any  OM  instance.  OM.binding(h,v1,v2,...,vn,b)  creates a new OpenMath binding in which\n   the head symbol  h  (which must be an OpenMath symbol node, an  OM \n   instance) binds the variables  v1  through  vn  (which must be OpenMath\n   variable nodes, also  OM  instances) in the body  b  (which can be any\n    OM  instance).  OM.error(s,c1,c2,...,cn)  creates a new OpenMath error object in which\n    s  is the head symbol (an  OM  instance representing an OpenMath symbol)\n   and there are zero or more other children  c1  through  cn  that can be\n   any  OM  instances   Example use:  \nplus = OM.symbol( 'plus', 'arith1' );\narg1 = OM.variable( 'x' );\narg2 = OM.integer( 5 );\nOM.application( plus, arg1, arg2 ).toXML(); // gives XML encoding for x+5  Because the above method can easily become annoyingly lengthy, we also\nprovide a shorthand for writing OpenMath expressions as strings and having\nthem parsed in a convenient way.  Full details are covered in  the source\ncode documentation\nhere .\nIt is called \"simple encoding and decoding,\" and you can create new  OM \ninstances from that encoding with the following function.   OM.simpleDecode(string)  creates a new  OM  instance decoded from the\n   given string.  If your input is invalid (not a string, or a string not\n   containing a valid simple encoding) then the return value will be a\n   string error message, rather than an  OM  instance.   Example usage:  \nOM.simpleDecode( 'plus.arith1(x,5)' ).toXML();  Each of the functions in this section have nicknames.  For each factory\nfunction given above, it has a three-letter nickname to help you write\nshorter code that builds OpenMath tree structures.  The nicknames are all in\nthe  OM  namespace, and include  int ,  flo ,  str ,  byt ,  sym ,  var , app ,  att ,  bin , and  err .  Thus, for instance, you can write the\nfollowing code to build a valid OpenMath expression.  \nOM.app( OM.sym( 'plus', 'arith1' ), OM.var( 'x' ), OM.int( 5 ) ).toXML();  Finally, the  simpleDecode  function also has the nickname  simple , so the\nmost compact form is the following.  \nOM.simple( 'plus.arith1(x,5)' ).toXML();  The  OM  objects are just wrappers around JSON tree structures that provide\nmethods for interacting with those tree structures.  You can get access to\nthe tree structur itself with  myInstance.tree .  It is not quite JSON,\nbecause it has circular references, as children nodes point to their parent\nnodes, but it is close to JSON.  The specification for how OpenMath expressions are stored as JSON trees is\ngiven  at the top of the source code documentation , should you need it.  The following methods are\navailable for working with such structures, but these are rarely used by the\nclient, and are mostly for internal purposes.   OM.checkJSON(jsonObject)  returns  null  if the object is valid JSON\n   that represents and OpenMath data structure, and thus could be wrapped in\n   an  OM  instance, or a string error message if it is not  OM.decode(jsonObject)  creates an  OM  instance by wrapping the given\n   object in an  OM  object, if possible, or throws an error if\n    OM.checkJSON  fails on the given input  OM.decode(string)  parses the string as JSON and then calls the previous\n   function.  OM(tree)  creates a new  OM  instance wrapping the given JSON tree; this\n   is the same as  OM.decode , but more compact.  Note that you can thus get\n   two instances that refer to the same internal data via\n    OM(otherInstance.tree) .", 
            "title": "Creating OpenMath objects"
        }, 
        {
            "location": "/api-reference/#writingsaving-openmath-objects", 
            "text": "instance.encode()  is the inverse of  OM.decode() , and yields a JSON\n   string useful for serializing instances in a compact way  instance.simpleEncode()  is the inverse of  OM.simpleDecode() , and\n   converts instances into the simple encoding mentioned above.  Note that\n   it does not support errors, byte arrays, or attributions.  instance.toXML()  yields the XML encoding defined in  the OpenMath\n   standard .", 
            "title": "Writing/saving OpenMath objects"
        }, 
        {
            "location": "/api-reference/#properties-of-openmath-objects", 
            "text": "instance.type  yields the type of an  OM  instance, a string containing\n   just one or two letters, one of i, f, st, ba, sy, v, a, bi, e, which mean\n   integer, float, string, bytearray, symbol, variable, application,\n   binding, and error, respectively.  These come directly from the JSON\n   encoding documented  here .  instance.value  yields the value of those atomic types that have one, as\n   an atomic JavaScript datum.  Integers and floats yield a JavaScript\n   number, strings yield a JavaScript string, and bytearrays yield a\n   JavaScript UInt8Array.  This property is undefined in all other cases.  instance.name  yields the string name of a variable or symbol, and is\n   undefined in all other cases.  instance.cd  yields the content dictionary of a symbol, and is\n   undefined in all other cases.  instance.uri  yields the base URI of a symbol, if one was provided, and\n   is undefined in all other cases.  instance.symbol  yields the head symbol for a binding or error object,\n   and is undefined in all other cases.  instance.body  yields the body of a binding object, and is undefined in\n   all other cases.  instance.children  yields a JavaScript array containing the child nodes\n   for application or error objects, and is an empty array in all other\n   cases.  It may be an empty array in the case of error objects as well,\n   if they have only a head symbol.  instance.variables  yields the list of variables bound by a binding\n   object, as a JavaScript array, and is undefined in all other cases.   Note that each of these properties is actually produced by a getter\nfunction, and thus is not always as efficient as you might think.  For\ninstance, you may not wish to write loops like this:  for ( var i = 0 ; i   anOMinstance.children.length ; i++ )\n    process( anOMinstance.children[i] ); // calls getter many times  Rather, you might do better with a loop like this:  for ( var i = 0, ch = anOMinstance.children ; i   ch.length ; i++ )\n    process( ch[i] ); // doesn't call getter at all on this line", 
            "title": "Properties of OpenMath Objects"
        }, 
        {
            "location": "/api-reference/#tree-related-functions", 
            "text": "As mentioned at the end of  the first section ,\nit is possible to create two different  OM  instances that refer to the same\ninternal tree structure.  And as mentioned immediately above, calling instance.children[i]  produces a new instance each time you call it.\nThus  instance.children[0]  and  instance.children[0]  will refer to the\nsame internal JSON structure, but will be different  OM  instances.  We can\nthus check equality in two ways.   instance.sameObjectAs(otherInstance)  asks whether two  OM  instances\n   refer to the same internal JSON data, the same node in the same tree.  instance.equals(other[,checkAttributes])  compares structural equality\n   only, and does not care whether the two instances are the same tree.  It\n   includes attributes in the comparison if and only if the second argument\n   is set to true, which is its default.  instance.copy()  makes a structural deep copy of an  OM  instance.   Examples:  \nA = OM.application( OM.variable( 'f', OM.integer( 3 ) ) ); // f(3)\nB = A.copy(); // deep copy\nC = A.children[0]; // builds a new OM instance for the f\nD = A.children[0]; // does the same thing again\nconsole.log( A.equals( B ) ); // true\nconsole.log( A.sameObjectAs( B ) ); // false\nconsole.log( A == B ); // false\nconsole.log( C.equals( D ) ); // true\nconsole.log( C.sameObjectAs( D ) ); // true\nconsole.log( C == D ); // false  You can also modify tree structures as follows.   instance.remove()  returns no value, but removes the instance from its\n   parent tree, if that does not break the parent tree's validity.  If it\n   does, this function takes no action.  For instance, you cannot remove\n   the head symbol from a binding or error structure.  instance.replaceWith(other)  replaces the instance in its parent\n   structure with the given other  OM  object, if the resulting tree would\n   be valid, or does nothing otherwise.  The original is returned on\n   success, and undefined is returned on failure.  instance.getAttribute(keySymbol)  returns the corresponding value for\n   the given key symbol (an  OM  instance) in the instance's attributes, if\n   there is one, or undefined if there is not.  instance.setAttribute(keySymbol,value)  adds or changes an attribute on\n   the instance.  The key symbol must be an  OM  symbol instance, and the\n   value must be any  OM  instance.", 
            "title": "Tree-Related Functions"
        }, 
        {
            "location": "/api-reference/#searching-openmath-trees", 
            "text": "We have devised a way for indexing and addressing children and descendants\nwithin parent/ancestor trees, and the following functions use that\nconvention.  You can read about the indexing/addressing convention  in the\nsource code documentation here .   instance.findInParent()  returns a single index of the form cn/vn/b/s,\n    or a JSON attribute key, or undefined if the instance has no parent, as\n    per the indexing scheme linked to above.  It returns undefined if there\n    is no such child.  instance.findChild(indexString)  is the inverse of the previous, in that\n   it takes as input a string that the previous might give as output, and\n   finds the corresponding child tree by that index.   Example:  \nA = OM.application( OM.variable( 'print' ),\n                        OM.string( 'Hello' ), OM.string( 'World' ) );\nstr1 = A.children[1]; // zero-based\nconsole.log( str1.value ); // \"Hello\"\nindex = str1.findInParent();\nconsole.log( index ); // \"c1\"\nchild = A.findChild( index );\nconsole.log( child.sameObjectAs( str1 ) ); // true   instance.address(inThisAncestor)  is a generalization of  indexInParent \n   to arbitrary depth.  It returns an array of indices that one would need\n   to follow, as a path, to walk from the given ancestor node, down through\n   the tree, to reach this instance.  If no ancestor is given (or a\n   non-ancestor is given) then the topmost ancestor is used instead.  instance.index(indexArray)  is the inverse of the previous function,\n   taking an array of indices and walking that path into its descendants,\n   returning the resulting subtree, or undefined if one or more of the steps\n   were invalid.   Examples:  \ndeepTree = OM.simple( 'arith1.plus(f(g(x,y)),h(k(z)))' );\ndescendant = deepTree.index( [ 'c1', 'c1', 'c2' ] );\nconsole.log( descendant.name ); // \"y\"\nconsole.log( descendant.address( deepTree ) ); // c1,c1,c2\nconsole.log( descendant.address( deepTree.children[1] ) ); // c1,c2  You can filter children or descendants by predicates.   instance.childrenSatisfying(P)  returns an array of all immediate\n   children c for which P(c) returns true.  This array may be empty.  For\n   the purposes of this function, immediate children include not only what\n   is returned by  instance.children , but also head symbols of bindings and\n   errors, and bodies of bindings.  instance.descendantsSatisfying(P)  is the same as the previous, but\n   considers indirect descendants as well.  Note that original subtrees are\n   returned, not copies, so modifying them will change the original\n   instance.  instance.hasDescendantsSatisfying(P)  returns true or false, equal to\n   calling  instance.descendantsSatisfying(P).length   0 , except this is\n   faster because it can stop searching once it has found one.", 
            "title": "Searching OpenMath Trees"
        }, 
        {
            "location": "/api-reference/#free-and-bound-variables", 
            "text": "Many applications of OpenMath relate to logic and/or programming, in which\nvariable binding and substitutin plays a critical role.  The following\nfunctions make it easy to ask questions and perform the most common\noperations related to variable binding and substitution.   instance.freeVariables()  returns and array of free variable names, as\n   strings, that appear anywhere as descendants of the instance.  Each name\n   is only reported once, even if it occurs many times.  This does not recur\n   into attributes or error children.  instance.isFree(inThisAncestor)  returns true if all variables free in\n   the instance are free in the given ancestor.  An invalid (or omitted)\n   ancestor causes the routine to use the top-most ancestor as well.  If any\n   variable free in the instance is not free in the ancestor, return false.  instance.occursFree(other)  returns true if there exists a descendant of\n   the instance that's structurally equivalent to  other  and that is free\n   where it occurs in the given instance, or returns false if there is not.  instance.isFreeToReplace(subtree,inThisAncestor)  returns true if\n   replacing the given subtree with the given instance would make any\n   variables free in the instance become bound in the given ancestor.  As\n   before, an invalid or omitted ancestor will use the topmost ancestor of\n   the subtree instead.  instance.replaceFree(original,replacement,inThisAncestor)  recursively\n   searches through all descendants D of the instance that are structurally\n   equiavlent to the given original, and whenever\n    replacement.isFreeToReplace(D,inThisAncestor)  yields true, call\n    D.replaceWith(replacement) .  It does not recur into attributes.", 
            "title": "Free and Bound Variables"
        }, 
        {
            "location": "/api-reference/#miscellany", 
            "text": "Sometimes it is useful to be able to take any JavaScript string and convert\nit into a string that could be used as a valid OpenMath identifier (such as\na variable or symbol name).  Because only a subset of Unicode is permitted,\nwe provide an injection (although not a very compact one) from all strings\ninto the set of strings accepted as valid OpenMath identifiers.  The range\nof the function is strings of the form \"id_[many decimal digits here]\".   OM.encodeAsIdentifier(anyString)  performs the encoding  OM.decodeIdentifier(encodedString)  inverts the previous function   Example:  \nconsole.log( OM.encodeAsIdentifier( '#$ & @' ) ); // id_0023002400260040\nconsole.log( OM.decodeIdentifier( \"id_0023002400260040\" ) ); // #$ & @  Some applications find it useful to be able to evaluate simple numerical\nOpenMath expressions.   instance.evaluate()  attempts to evaluate a numerical expression that\n   uses the basic operations of arithmetic, powers, roots, trigonometry,\n   pi, e, and a few other simple concepts.  It returns a JavaScript object\n   with two members,  value  contains the numerical value (if one was able\n   to be computed) and  message  is a string that may contain some details,\n   such as when rounding needed to occur.   Example:  \nconsole.log( OM.simple( 'transc1.cos(0)' ).evaluate() ); // 1\nconsole.log( OM.simple( 'f(x)' ).evaluate() ); // error message\nconsole.log( OM.simple( 'e' ).evaluate() ); // 2.71828... w/rounding message   \nvar elements = document.getElementsByClassName( 'runnable-example' );\nfor ( var i = 0 ; i < elements.length ; i++ ) {\n    var source = elements[i].textContent;\n    elements[i].textContent = '';\n    var notebook = RunKit.createNotebook( {\n        element: elements[i],\n        source: source,\n        preamble: 'OM = require( \"openmath-js\" ).OM;'\n    } );\n}", 
            "title": "Miscellany"
        }
    ]
}